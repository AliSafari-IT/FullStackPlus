"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeConfigToV2 = exports.isNxDotnetConfigV1 = exports.deepMerge = exports.readConfigFromNxJson = exports.readConfigFromRCFile = exports.readConfigSection = exports.updateConfigInNxJson = exports.updateConfig = exports.readConfig = exports.DefaultConfigValues = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const constants_1 = require("../constants");
const semver_1 = require("semver");
exports.DefaultConfigValues = {
    solutionFile: '{npmScope}.nx-dotnet.sln',
    inferProjects: true,
    nugetPackages: {},
    inferredTargets: {
        build: 'build',
        lint: 'lint',
        serve: 'serve',
        test: 'test',
    },
    ignorePaths: [],
    tags: ['nx-dotnet'],
};
function readConfig(host) {
    const configFromFile = readConfigFromRCFile(host);
    const configFromNxJson = readConfigFromNxJson(host);
    return deepMerge(exports.DefaultConfigValues, isNxDotnetConfigV1(configFromFile)
        ? upgradeConfigToV2(configFromFile)
        : configFromFile, isNxDotnetConfigV1(configFromNxJson)
        ? upgradeConfigToV2(configFromNxJson)
        : configFromNxJson);
}
exports.readConfig = readConfig;
function updateConfig(host, value) {
    if ((0, semver_1.major)(devkit_1.NX_VERSION) < 17) {
        (0, devkit_1.writeJson)(host, constants_1.CONFIG_FILE_PATH, value);
    }
    else {
        updateConfigInNxJson(host, value);
    }
}
exports.updateConfig = updateConfig;
function updateConfigInNxJson(host, value) {
    var _a;
    const nxJson = (0, devkit_1.readNxJson)(host);
    if (!nxJson) {
        throw new Error('nx-dotnet requires nx.json to be present in the workspace');
    }
    (_a = nxJson.plugins) !== null && _a !== void 0 ? _a : (nxJson.plugins = []);
    const pluginIndex = nxJson.plugins.findIndex((p) => typeof p === 'string'
        ? p === '@nx-dotnet/core'
        : p.plugin === '@nx-dotnet/core');
    if (pluginIndex > -1) {
        nxJson.plugins[pluginIndex] = {
            plugin: '@nx-dotnet/core',
            // Remove cast after next beta
            options: value,
        };
    }
    else {
        throw new Error('nx-dotnet requires @nx-dotnet/core to be present in nx.json');
    }
    (0, devkit_1.writeJson)(host, 'nx.json', nxJson);
}
exports.updateConfigInNxJson = updateConfigInNxJson;
function readConfigSection(host, section) {
    const config = readConfig(host);
    return config[section] || exports.DefaultConfigValues[section];
}
exports.readConfigSection = readConfigSection;
function readConfigFromRCFile(host) {
    try {
        if (host) {
            return (0, devkit_1.readJson)(host, constants_1.CONFIG_FILE_PATH);
        }
        else {
            return (0, devkit_1.readJsonFile)(`${devkit_1.workspaceRoot}/${constants_1.CONFIG_FILE_PATH}`);
        }
    }
    catch (_a) {
        return null;
    }
}
exports.readConfigFromRCFile = readConfigFromRCFile;
function readConfigFromNxJson(host) {
    var _a;
    if ((0, semver_1.major)(devkit_1.NX_VERSION) < 17) {
        return null;
    }
    try {
        const nxJson = host
            ? (0, devkit_1.readNxJson)(host)
            : (0, devkit_1.readJsonFile)(`${devkit_1.workspaceRoot}/nx.json`);
        const plugin = (_a = nxJson === null || nxJson === void 0 ? void 0 : nxJson.plugins) === null || _a === void 0 ? void 0 : _a.find((p) => typeof p === 'string'
            ? p === '@nx-dotnet/core'
            : p.plugin === '@nx-dotnet/core');
        if (!plugin || typeof plugin === 'string') {
            return null;
        }
        else {
            return plugin.options;
        }
    }
    catch (_b) {
        return null;
    }
}
exports.readConfigFromNxJson = readConfigFromNxJson;
function deepMerge(base, ...objects) {
    function isObject(obj) {
        return !!obj && typeof obj === 'object';
    }
    return objects.reduce((agg, obj) => {
        if (obj === null || obj === undefined) {
            return agg;
        }
        Object.keys(obj).forEach((key) => {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const aggVal = agg[key];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const nextVal = obj[key];
            if (Array.isArray(aggVal) && Array.isArray(nextVal)) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                agg[key] = aggVal.concat(...nextVal);
            }
            else if (isObject(aggVal) && isObject(nextVal)) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                agg[key] = deepMerge(aggVal, nextVal);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                agg[key] = nextVal;
            }
        });
        return agg;
    }, JSON.parse(JSON.stringify(base)));
}
exports.deepMerge = deepMerge;
function isNxDotnetConfigV1(config) {
    return !!config && 'inferProjectTargets' in config;
}
exports.isNxDotnetConfigV1 = isNxDotnetConfigV1;
function upgradeConfigToV2(config) {
    const { inferProjectTargets } = config, v2compatible = tslib_1.__rest(config, ["inferProjectTargets"]);
    return Object.assign(Object.assign({}, v2compatible), { inferredTargets: inferProjectTargets !== false
            ? exports.DefaultConfigValues.inferredTargets
            : false });
}
exports.upgradeConfigToV2 = upgradeConfigToV2;
//# sourceMappingURL=config.js.map