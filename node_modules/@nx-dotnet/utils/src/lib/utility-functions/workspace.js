"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inlineNxTokens = exports.getProjectFilesForProject = exports.getNxDotnetProjects = exports.getDependenciesFromXmlFile = exports.getDependantProjectsForNxProject = exports.getProjectFileForNxProjectSync = exports.getProjectFileForNxProject = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const xmldoc_1 = require("xmldoc");
const glob_1 = require("./glob");
const path_2 = require("./path");
function getProjectFileForNxProject(project) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const srcDirectory = project.root;
        return (0, glob_1.findProjectFileInPath)(srcDirectory);
    });
}
exports.getProjectFileForNxProject = getProjectFileForNxProject;
function getProjectFileForNxProjectSync(project) {
    const srcDirectory = project.root;
    return (0, glob_1.findProjectFileInPathSync)(srcDirectory);
}
exports.getProjectFileForNxProjectSync = getProjectFileForNxProjectSync;
function getDependantProjectsForNxProject(targetProject, projectsConfiguration, forEachCallback) {
    const projectRoots = {};
    const dependantProjects = {};
    Object.entries(projectsConfiguration.projects).forEach(([name, project]) => {
        projectRoots[project.root] = name;
    });
    const absoluteNetProjectFilePath = (0, path_1.resolve)(devkit_1.workspaceRoot, getProjectFileForNxProjectSync(projectsConfiguration.projects[targetProject]));
    const dependencies = getDependenciesFromXmlFile(absoluteNetProjectFilePath, targetProject, projectRoots);
    for (const dependency of dependencies) {
        const project = projectsConfiguration.projects[dependency.target];
        if (!project) {
            throw new Error(`Unable to find project ${dependency.target} in workspace`);
        }
        if (forEachCallback) {
            forEachCallback(project, dependency.target, dependency.type === devkit_1.DependencyType.implicit);
        }
        dependantProjects[dependency.target] = project;
    }
    return dependantProjects;
}
exports.getDependantProjectsForNxProject = getDependantProjectsForNxProject;
function getDependenciesFromXmlFile(filePath, source, projectRootMap) {
    const found = [];
    const absoluteNetProjectFilePath = (0, path_2.getAbsolutePath)(filePath, devkit_1.workspaceRoot);
    const netProjectFilePath = normalizePath((0, path_1.relative)(devkit_1.workspaceRoot, absoluteNetProjectFilePath));
    const hostProjectDirectory = normalizePath((0, path_1.dirname)(absoluteNetProjectFilePath));
    const xml = tryGetXmlDocument(absoluteNetProjectFilePath);
    if (!xml) {
        return found;
    }
    xml.childrenNamed('ItemGroup').forEach((itemGroup) => itemGroup.childrenNamed('ProjectReference').forEach((x) => {
        const includeFilePath = normalizePath(x.attr['Include']);
        const implicit = x.attr['ReferenceOutputAssembly'] === 'false';
        const absoluteIncludedPath = (0, path_2.getAbsolutePath)(includeFilePath, hostProjectDirectory);
        const workspaceFilePath = normalizePath((0, path_1.relative)(devkit_1.workspaceRoot, absoluteIncludedPath));
        let potentialTargetRoot = (0, path_1.dirname)(workspaceFilePath);
        while (potentialTargetRoot !== devkit_1.workspaceRoot &&
            potentialTargetRoot !== '.') {
            if (projectRootMap[potentialTargetRoot]) {
                found.push({
                    source,
                    target: projectRootMap[potentialTargetRoot],
                    type: implicit ? devkit_1.DependencyType.implicit : devkit_1.DependencyType.static,
                    sourceFile: netProjectFilePath,
                });
                break;
            }
            potentialTargetRoot = (0, path_1.dirname)(potentialTargetRoot);
        }
    }));
    return found;
}
exports.getDependenciesFromXmlFile = getDependenciesFromXmlFile;
function getNxDotnetProjects(host) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const allProjects = (0, devkit_1.getProjects)(host);
        for (const [key, p] of allProjects) {
            let isNetProject = false;
            for (const pattern of ['*.csproj', '*.fsproj', '*.vbproj']) {
                const matches = yield (0, glob_1.glob)(pattern, p === null || p === void 0 ? void 0 : p.root);
                if (matches === null || matches === void 0 ? void 0 : matches.length) {
                    isNetProject = true;
                    break;
                }
            }
            if (!isNetProject) {
                allProjects.delete(key);
            }
        }
        return allProjects;
    });
}
exports.getNxDotnetProjects = getNxDotnetProjects;
function getProjectFilesForProject(host, project, projectName) {
    var _a;
    if (!(project === null || project === void 0 ? void 0 : project.sourceRoot) && !(project === null || project === void 0 ? void 0 : project.root)) {
        throw new Error(`Unable to read source root for project ${projectName}`);
    }
    return host
        .children((_a = project.sourceRoot) !== null && _a !== void 0 ? _a : project.root)
        .filter((x) => x.endsWith('proj'))
        .map((x) => { var _a; return `${(_a = project.sourceRoot) !== null && _a !== void 0 ? _a : project.root}/${x}`; });
}
exports.getProjectFilesForProject = getProjectFilesForProject;
/**
 * Currently @nx/devkit[normalizePath] functionality differs a bit based on OS. See
 */
function normalizePath(p) {
    return (0, devkit_1.normalizePath)(p).split('\\').join('/');
}
function inlineNxTokens(value, project) {
    if (value.startsWith('{workspaceRoot}/')) {
        value = value.replace(/^\{workspaceRoot\}\//, '');
    }
    if (value.includes('{workspaceRoot}')) {
        throw new Error(`[nx-dotnet] The {workspaceRoot} token is only valid at the beginning of an output.`);
    }
    value = value.replace('{projectRoot}', project.root);
    return value.replace('{projectName}', project.name);
}
exports.inlineNxTokens = inlineNxTokens;
function tryGetXmlDocument(file) {
    try {
        return new xmldoc_1.XmlDocument((0, fs_1.readFileSync)(file).toString());
    }
    catch (_a) {
        return null;
    }
}
//# sourceMappingURL=workspace.js.map