"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotNetClient = void 0;
const child_process_1 = require("child_process");
const semver = require("semver");
const utils_1 = require("@nx-dotnet/utils");
const models_1 = require("../models");
const parse_dotnet_new_list_output_1 = require("../utils/parse-dotnet-new-list-output");
class DotNetClient {
    constructor(cliCommand, cwd) {
        this.cliCommand = cliCommand;
        this.cwd = cwd;
    }
    new(template, parameters, additionalArguments) {
        const params = [`new`, template];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.newKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        params.push(...(additionalArguments !== null && additionalArguments !== void 0 ? additionalArguments : []));
        return this.logAndExecute(params);
    }
    listInstalledTemplates(opts) {
        const version = this.getSdkVersion();
        const params = ['new'];
        if (semver.lt(version, '6.0.100') && (opts === null || opts === void 0 ? void 0 : opts.search)) {
            params.push(opts.search);
        }
        if (semver.gte(version, '7.0.100')) {
            params.push('list');
        }
        else {
            params.push('--list');
        }
        if (semver.gte(version, '6.0.100') && (opts === null || opts === void 0 ? void 0 : opts.search)) {
            params.push(opts.search);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.language) {
            params.push('--language', opts.language);
        }
        const output = this.spawnAndGetOutput(params);
        return (0, parse_dotnet_new_list_output_1.parseDotnetNewListOutput)(output);
    }
    build(project, parameters, extraParameters) {
        const params = [`build`, project];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.buildKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        if (extraParameters) {
            const matches = extraParameters.match(EXTRA_PARAMS_REGEX);
            params.push(...matches);
        }
        return this.logAndExecute(params);
    }
    run(project, watch = false, parameters) {
        const params = watch
            ? [`watch`, `--project`, project, `run`]
            : [`run`, `--project`, project];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.runKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        return this.logAndSpawn(params);
    }
    test(project, watch, parameters, extraParameters) {
        const params = watch
            ? [`watch`, `--project`, project, `test`]
            : [`test`, project];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.testKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        if (extraParameters) {
            const matches = extraParameters.match(EXTRA_PARAMS_REGEX);
            params.push(...matches);
        }
        if (!watch) {
            return this.logAndExecute(params);
        }
        else {
            return this.logAndSpawn(params);
        }
    }
    addPackageReference(project, pkg, parameters) {
        const params = [`add`, project, `package`, pkg];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.addPackageKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        return this.logAndExecute(params);
    }
    addProjectReference(hostCsProj, targetCsProj) {
        return this.logAndExecute([`add`, hostCsProj, `reference`, targetCsProj]);
    }
    publish(project, parameters, publishProfile, extraParameters) {
        const params = [`publish`, `"${project}"`];
        if (parameters) {
            parameters = (0, utils_1.swapKeysUsingMap)(parameters, models_1.publishKeyMap);
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        if (publishProfile) {
            params.push(`-p:PublishProfile=${publishProfile}`);
        }
        if (extraParameters) {
            const matches = extraParameters.match(EXTRA_PARAMS_REGEX);
            params.push(...matches);
        }
        return this.logAndExecute(params);
    }
    installTool(tool, version, source) {
        const cmd = [`tool`, `install`, tool];
        if (version) {
            cmd.push('--version', version);
        }
        if (source) {
            cmd.push('--add-source', source);
        }
        return this.logAndExecute(cmd);
    }
    restorePackages(project) {
        const cmd = [`restore`, project];
        return this.logAndExecute(cmd);
    }
    restoreTools() {
        const cmd = [`tool`, `restore`];
        return this.logAndExecute(cmd);
    }
    format(project, parameters, forceToolUsage) {
        const params = getFormatBaseArgv(forceToolUsage);
        parameters = updateFormatParametersForVersionCompatibility(this.getSdkVersion(), parameters);
        if (semver.major(this.getSdkVersion()) >= 6 &&
            ((parameters === null || parameters === void 0 ? void 0 : parameters.fixWhitespace) !== undefined ||
                (parameters === null || parameters === void 0 ? void 0 : parameters.fixStyle) !== undefined ||
                (parameters === null || parameters === void 0 ? void 0 : parameters.fixAnalyzers) !== undefined)) {
            // The handling of these 3 options changed in .NET 6.
            // Now, we need to run the command separately for each option that isn't disabled
            // if any of them were disabled or modified.
            const whitespace = parameters.fixWhitespace;
            const style = parameters.fixStyle;
            const analyzers = parameters.fixAnalyzers;
            delete parameters.fixWhitespace;
            delete parameters.fixStyle;
            delete parameters.fixAnalyzers;
            if (whitespace !== false) {
                const subcommandParams = [...params, 'whitespace', project];
                const subcommandParameterObject = Object.assign({}, parameters);
                subcommandParams.push(...(0, utils_1.getSpawnParameterArray)((0, utils_1.swapKeysUsingMap)(subcommandParameterObject, models_1.formatKeyMap)));
                this.logAndExecute(subcommandParams);
            }
            if (style !== false) {
                const subcommandParams = [...params, 'style', project];
                const subcommandParameterObject = Object.assign({}, parameters);
                if (typeof style === 'string') {
                    subcommandParameterObject.severity = style;
                }
                subcommandParams.push(...(0, utils_1.getSpawnParameterArray)((0, utils_1.swapKeysUsingMap)(subcommandParameterObject, models_1.formatKeyMap)));
                this.logAndExecute(subcommandParams);
            }
            if (analyzers !== false) {
                const subcommandParams = [...params, 'analyzers', project];
                const subcommandParameterObject = Object.assign({}, parameters);
                if (typeof analyzers === 'string') {
                    subcommandParameterObject.severity = analyzers;
                }
                subcommandParams.push(...(0, utils_1.getSpawnParameterArray)((0, utils_1.swapKeysUsingMap)(subcommandParameterObject, models_1.formatKeyMap)));
                this.logAndExecute(subcommandParams);
            }
        }
        else {
            params.push(project);
            if (parameters) {
                params.push(...(0, utils_1.getSpawnParameterArray)((0, utils_1.swapKeysUsingMap)(parameters, models_1.formatKeyMap)));
            }
            return this.logAndExecute(params);
        }
    }
    runTool(tool, positionalParameters, parameters, extraParameters) {
        const params = ['tool', 'run', tool];
        if (positionalParameters) {
            params.push(...positionalParameters);
        }
        if (parameters) {
            params.push(...(0, utils_1.getSpawnParameterArray)(parameters));
        }
        if (extraParameters) {
            const matches = extraParameters.match(EXTRA_PARAMS_REGEX);
            params.push(...matches);
        }
        return this.logAndExecute(params);
    }
    addProjectToSolution(solutionFile, project) {
        const params = [`sln`, solutionFile, `add`, project];
        this.logAndExecute(params);
    }
    getSdkVersion() {
        return this.cliCommand.info.version.toString();
    }
    printSdkVersion() {
        this.logAndExecute(['--version']);
    }
    logAndExecute(params) {
        var _a;
        params = params.map((param) => param.replace(/\$(\w+)/, (_, varName) => { var _a; return (_a = process.env[varName]) !== null && _a !== void 0 ? _a : ''; }));
        const cmd = `${this.cliCommand.command} "${params.join('" "')}"`;
        console.log(`Executing Command: ${cmd}`);
        const res = (0, child_process_1.spawnSync)(this.cliCommand.command, params, {
            cwd: (_a = this.cwd) !== null && _a !== void 0 ? _a : process.cwd(),
            stdio: 'inherit',
        });
        if (res.status !== 0) {
            throw new Error(`dotnet execution returned status code ${res.status}`);
        }
    }
    spawnAndGetOutput(params) {
        var _a;
        params = params.map((param) => param.replace(/\$(\w+)/, (_, varName) => { var _a; return (_a = process.env[varName]) !== null && _a !== void 0 ? _a : ''; }));
        const res = (0, child_process_1.spawnSync)(this.cliCommand.command, params, {
            cwd: (_a = this.cwd) !== null && _a !== void 0 ? _a : process.cwd(),
            stdio: 'pipe',
        });
        if (res.status !== 0) {
            throw new Error(`dotnet execution returned status code ${res.status} \n ${res.stderr}`);
        }
        return res.stdout.toString();
    }
    logAndSpawn(params) {
        var _a;
        console.log(`Executing Command: ${this.cliCommand.command} "${params.join('" "')}"`);
        return (0, child_process_1.spawn)(this.cliCommand.command, params, {
            stdio: 'inherit',
            cwd: (_a = this.cwd) !== null && _a !== void 0 ? _a : process.cwd(),
        });
    }
}
exports.DotNetClient = DotNetClient;
/**
 * Regular Expression for Parsing Extra Params before sending to spawn / exec
 * First part of expression matches parameters such as --flag="my answer"
 * Second part of expression matches parameters such as --flag=my_answer
 */
const EXTRA_PARAMS_REGEX = /\S*".+?"|\S+/g;
function getFormatBaseArgv(forceToolUsage) {
    return forceToolUsage ? ['tool', 'run', 'dotnet-format', '--'] : [`format`];
}
function updateFormatParametersForVersionCompatibility(sdkVersion, parameters) {
    var _a, _b;
    // The --check flag is for .NET 5 and older
    // The --verify-no-changes flag is for .NET 6 and newer
    // They do the same thing, but the flag name changed in .NET 6, so we need to handle that.
    if (parameters) {
        if (semver.major(sdkVersion) >= 6) {
            (_a = parameters.verifyNoChanges) !== null && _a !== void 0 ? _a : (parameters.verifyNoChanges = parameters.check);
            delete parameters.check;
        }
        else {
            (_b = parameters.check) !== null && _b !== void 0 ? _b : (parameters.check = parameters.verifyNoChanges);
            delete parameters.verifyNoChanges;
        }
    }
    return parameters;
}
//# sourceMappingURL=dotnet.client.js.map